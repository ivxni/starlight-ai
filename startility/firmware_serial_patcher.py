"""
Startility - Wooting 60HE ARM Serial Patcher
=============================================
Patches the firmware serial format string to output a custom serial.

Technique:
  The serial string "A02B2247W052H16911" is generated by sprintf() using
  the format string at 0x0802C538:
    "A%02uB%02u%02uW%02u%s%01u%s%s%c%05lu"
  (38 bytes including null terminator)

  By replacing this format string with a literal serial string (no %
  specifiers), sprintf() will copy it verbatim, ignoring the original
  arguments. This is safe because:
  - sprintf with no format specifiers and extra args is well-defined
  - The output buffer is large enough for the original serial (18 chars)
  - The new serial is padded to the same format string length

  We also check/patch the nearby format strings T%02u, %02u, S%02u
  which may be used for alternate serial prefixes.
"""

import sys
import struct
import os
from intelhex import IntelHex

FW_PATH = os.path.join(os.environ.get('TEMP', '/tmp'),
                       'wootility-src', 'dist', 'fw', 'wooting_60_he_arm.fwr')

# Serial format string location and content
SERIAL_FMT_ADDR = 0x0802C538
SERIAL_FMT_ORIG = b"A%02uB%02u%02uW%02u%s%01u%s%s%c%05lu\x00"  # 38 bytes
SERIAL_FMT_SIZE = len(SERIAL_FMT_ORIG)  # 38

# USB Device Descriptor location
USB_DEV_DESC_ADDR = 0x0802CDFC

# String pointer table (before device descriptor)
# 0x0802CDF0: ptr to "Wooting"         (iManufacturer=1)
# 0x0802CDF4: ptr to "Wooting 60HE"    (iProduct=2)
# 0x0802CDF8: ptr to serial buffer     (iSerialNumber=3)
STR_PTR_TABLE_ADDR = 0x0802CDE8


def load_firmware(path):
    """Load Intel HEX firmware."""
    print(f"[*] Loading: {path}")
    ih = IntelHex(path)
    start = ih.minaddr()
    end = ih.maxaddr()
    binary = bytes(ih.tobinarray(start=start, size=end - start + 1))
    print(f"    Range: 0x{start:08X} - 0x{end:08X} ({len(binary):,} bytes)")
    return ih, binary, start


def verify_firmware(binary, base):
    """Verify we have the expected firmware by checking known patterns."""
    print("\n[*] Verifying firmware integrity...")
    
    checks = [
        (SERIAL_FMT_ADDR, SERIAL_FMT_ORIG[:-1], "Serial format string"),
        (0x0802C638, b"Wooting\x00", "Manufacturer string"),
        (0x0802C640, b"Wooting 60HE (ARM)\x00", "Product string"),
    ]
    
    all_ok = True
    for addr, expected, name in checks:
        offset = addr - base
        actual = binary[offset:offset + len(expected)]
        match = actual == expected
        status = "OK" if match else "MISMATCH"
        print(f"    {name}: [{status}]")
        if not match:
            print(f"      Expected: {expected.hex()}")
            print(f"      Actual:   {actual.hex()}")
            all_ok = False
    
    # Check USB device descriptor
    desc_offset = USB_DEV_DESC_ADDR - base
    desc = binary[desc_offset:desc_offset + 18]
    if desc[0] == 0x12 and desc[1] == 0x01:
        vid = struct.unpack_from("<H", desc, 8)[0]
        pid = struct.unpack_from("<H", desc, 10)[0]
        iserial = desc[16]
        print(f"    USB Descriptor: VID=0x{vid:04X} PID=0x{pid:04X} "
              f"iSerial={iserial} [OK]")
    else:
        print(f"    USB Descriptor: [NOT FOUND at expected location]")
        all_ok = False
    
    # Show string pointer table
    ptr_offset = STR_PTR_TABLE_ADDR - base
    print(f"\n    String pointer table at 0x{STR_PTR_TABLE_ADDR:08X}:")
    for i in range(5):
        ptr = struct.unpack_from("<I", binary, ptr_offset + i * 4)[0]
        # Try to read pointed-to string
        str_offset = ptr - base
        if 0 <= str_offset < len(binary):
            s = b""
            j = str_offset
            while j < len(binary) and binary[j] != 0 and len(s) < 40:
                s += bytes([binary[j]])
                j += 1
            try:
                txt = s.decode('ascii')
            except:
                txt = s.hex()
        else:
            txt = "(outside firmware)"
        print(f"      [{i}] 0x{ptr:08X} -> '{txt}'")
    
    return all_ok


def patch_serial(ih, binary, base, new_serial, output_path):
    """Patch the serial format string with a literal serial."""
    
    if len(new_serial) >= SERIAL_FMT_SIZE:
        print(f"[-] Serial too long! Max {SERIAL_FMT_SIZE - 1} chars, "
              f"got {len(new_serial)}")
        return False
    
    # Encode new serial as null-terminated ASCII, padded to original size
    new_bytes = new_serial.encode('ascii') + b'\x00'
    new_bytes += b'\x00' * (SERIAL_FMT_SIZE - len(new_bytes))
    
    assert len(new_bytes) == SERIAL_FMT_SIZE
    
    print(f"\n[*] Patching serial format string:")
    print(f"    Address:  0x{SERIAL_FMT_ADDR:08X}")
    print(f"    Original: '{SERIAL_FMT_ORIG[:-1].decode()}'")
    print(f"    Patched:  '{new_serial}' + null padding")
    print(f"    Size:     {SERIAL_FMT_SIZE} bytes (unchanged)")
    
    # Write patch to IntelHex
    for i, b in enumerate(new_bytes):
        ih[SERIAL_FMT_ADDR + i] = b
    
    # Also patch the smaller format strings nearby that might be used
    # for alternate serial prefixes (T%02u, %02u, S%02u)
    # These are at 0x0802C520, 0x0802C528, 0x0802C530
    # We leave them alone since they're for different product lines
    
    # Write output
    ih.write_hex_file(output_path)
    
    # Verify
    print(f"\n[+] Patched firmware written to: {output_path}")
    
    # Re-read and verify
    ih2 = IntelHex(output_path)
    patched = bytes([ih2[SERIAL_FMT_ADDR + i] for i in range(len(new_serial) + 1)])
    expected = new_serial.encode('ascii') + b'\x00'
    if patched == expected:
        print(f"[+] Verification: PASS")
        print(f"    Read back: '{patched[:-1].decode()}'")
    else:
        print(f"[-] Verification: FAIL")
        print(f"    Expected: {expected.hex()}")
        print(f"    Got:      {patched.hex()}")
        return False
    
    return True


def show_analysis(binary, base):
    """Show analysis of serial-related firmware structures."""
    print("\n" + "=" * 60)
    print("  FIRMWARE ANALYSIS")
    print("=" * 60)
    
    # Show the serial format string region
    fmt_offset = SERIAL_FMT_ADDR - base
    print(f"\n  Serial format string at 0x{SERIAL_FMT_ADDR:08X}:")
    fmt = binary[fmt_offset:binary.index(0, fmt_offset)]
    print(f"    '{fmt.decode('ascii')}'")
    
    # Show format breakdown
    print(f"\n  Format generates serial like: A02B2247W052H16911")
    print(f"    A          = literal in format")
    print(f"    %02u (02)  = SupplierNumber")
    print(f"    B          = literal in format")
    print(f"    %02u (22)  = Year")
    print(f"    %02u (47)  = WeekNumber")
    print(f"    W          = literal in format")
    print(f"    %02u (05)  = RevisionNumber")
    print(f"    %s%01u%s%s = various fields")
    print(f"    %c (H)     = ProductId char")
    print(f"    %05lu      = ProductNumber")
    
    # Check serial buffer address from pointer table
    ptr_offset = STR_PTR_TABLE_ADDR - base + 4 * 4  # 5th pointer (index 4?)
    serial_buf_ptr = struct.unpack_from("<I", binary, ptr_offset)[0]
    print(f"\n  Serial buffer pointer: 0x{serial_buf_ptr:08X}")
    
    buf_offset = serial_buf_ptr - base
    if 0 <= buf_offset < len(binary):
        buf_data = binary[buf_offset:buf_offset + 40]
        print(f"    Content: {buf_data[:20].hex()}")
        try:
            txt = ""
            for b in buf_data:
                if b == 0:
                    break
                txt += chr(b)
            if txt:
                print(f"    As text: '{txt}'")
        except:
            pass


def main():
    print("=" * 60)
    print("  Startility - Serial Patcher v1.0")
    print("=" * 60)
    
    fw_path = FW_PATH
    if len(sys.argv) > 1 and not sys.argv[1].startswith('-'):
        fw_path = sys.argv[1]
    
    if not os.path.exists(fw_path):
        print(f"\n[-] Firmware not found: {fw_path}")
        sys.exit(1)
    
    ih, binary, base = load_firmware(fw_path)
    
    if '--analyze' in sys.argv or len(sys.argv) < 2:
        ok = verify_firmware(binary, base)
        show_analysis(binary, base)
        if not ok:
            print("\n[-] Firmware verification failed!")
            sys.exit(1)
    
    if '--patch' in sys.argv:
        # Get new serial from args
        try:
            idx = sys.argv.index('--patch')
            new_serial = sys.argv[idx + 1]
        except (IndexError, ValueError):
            print("\n[-] Usage: --patch NEW_SERIAL")
            print("    Example: --patch X99Z9999Y999Z99999")
            sys.exit(1)
        
        # Validate
        if not all(c.isalnum() for c in new_serial):
            print(f"[-] Serial must be alphanumeric, got: '{new_serial}'")
            sys.exit(1)
        
        if len(new_serial) > 37:
            print(f"[-] Serial too long ({len(new_serial)} chars, max 37)")
            sys.exit(1)
        
        output = os.path.join(
            os.path.dirname(os.path.abspath(__file__)),
            "wooting_60he_arm_patched.fwr"
        )
        
        ok = verify_firmware(binary, base)
        if not ok:
            print("\n[-] Firmware verification failed, aborting patch!")
            sys.exit(1)
        
        if patch_serial(ih, binary, base, new_serial, output):
            print(f"\n{'=' * 60}")
            print(f"  SUCCESS - Firmware patched!")
            print(f"  New serial: {new_serial}")
            print(f"  Output:     {output}")
            print(f"{'=' * 60}")
            print(f"\n  Next steps:")
            print(f"  1. Put keyboard in bootloader mode (Backspace + Fn)")
            print(f"  2. Flash patched firmware via bootloader")
            print(f"  3. Verify new serial with GET_SERIAL command")
        else:
            print("\n[-] Patching failed!")
            sys.exit(1)


if __name__ == "__main__":
    main()
